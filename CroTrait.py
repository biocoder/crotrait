# -*- coding: utf-8 -*-

from __future__ import print_function
import os
import sys
import subprocess
from Bio.Seq import Seq
from Bio import Phylo
import argparse
import numpy as np
import matplotlib.pyplot as plt
import argparse
import pandas as pd
import random
import platform


seven_species = ["condimenti","dublinensis","malonaticus","muytjensii",
				 "sakazakii","turicensis","universalis"]

species_Oserotype = {"condimenti":["CO1"],
					"dublinensis":["DO1a", "DO1b", "DO2"],
					"malonaticus":["MaO1", "MaO2", "MaO3", "MaO4"],
					"muytjensii":["MuO1", "MuO2", "MuO3"],
					"sakazakii":["SO1", "SO2", "SO3", "SO4", "SO7"],
					"turicensis":["TO1", "TO3", "TO4"],
					"universalis":["UO1"]}

seven_genes = ["atpD","fusA","glnS","gltB","gyrB","infB","pps"]

def randomcolor():
    colorArr = ['1','2','3','4','5','6','7','8','9','A','B','C','D','E','F']
    color = ""
    for i in range(6):
        color += colorArr[random.randint(0,14)]
    return "#"+color


def tran_sequence(sequence, path1=os.getcwd(), path2=os.getcwd()):
	"""
	Parameters
	----------
	sequence : sequence file
		input sequence file name don't contain path.
	path1 : original path
		the original path for sequence. The default is os.getcwd().
	path2 : aim path
		the aim path for sequence. The default is os.getcwd().
	Returns
	-------
	new fasta file
	"""
	g_name = sequence[::-1]
	g_name = g_name[g_name.find(".")+1:][::-1]
	wf = open(os.path.join(path2, g_name+"_re.fasta"), "w")
	trait = "wlu"
	with open(os.path.join(path1, sequence)) as f:
		for line in f:
			if ">" in line:
				contig_name = line.strip("\n").split(" ")[0][1:]
				if trait == "wlu":
					wf.write(">"+contig_name+"\n")
					trait = "wlei"
				else:
					wf.write("\n>"+contig_name+"\n")
			else:
				wf.write(line.strip("\n"))
	wf.write("\n")
	wf.close()

def seperate_sequence(sequence):
	"""
	Parameters
	----------
	sequence : input sequence
		input sequence file in fasta format.
	Returns
	-------
	list about contig name
	dictionary about contig sequence
	dictionary about contig length

	"""
	contig_sequence = dict()
	contig_name = list()
	contig_length = dict()
	with open(sequence, "r") as f:
		for line in f:
			if ">" in line:
				m = line.strip("\n")[1:]
				seq = next(f).strip("\n")
				contig_sequence[m] = seq
				contig_name.append(m)
				contig_length[m] = len(seq)
	return(contig_name, contig_sequence, contig_length)

def extract_species(tree, genome_name, species = seven_species):
	"""
	Parameters
	----------
	tree : nwk tree
		nwk tree generated by megacc.
	genome_name : genome name
		the query genome name.
	species : seven species
		the seven species of Cronobacter. The default is seven_species.
	Returns
	-------
	identified species
	"""
	with open(tree) as f:
		nwk_tree = f.readline().strip("\n")
		tree1 = nwk_tree[nwk_tree.find(genome_name):]
		tree1 = tree1[:tree1.find(")")]
		tree2 = nwk_tree[:nwk_tree.find(genome_name)]
		tree2 = tree2[::-1]
		tree2 = tree2[:tree2.find("(")][::-1]
		tree3 = tree2+tree1
		name1 = tree3.split(",")[0].split(":")[0]
		name2 = tree3.split(",")[1].split(":")[0]
		if len(tree3.split(",")) == 2:
			if genome_name == name1 and name2[:-1] in species:
				return(name2[:-1])
			elif genome_name == name2 and name1[:-1] in species:
				return(name1[:-1])
			else:
				return("bad")
		else:
			return("bad")

def extract_type(sequence, serotype, out):
	O_type = list(seperate_sequence(sequence))
	nm = O_type[0]
	seq = O_type[1]
	wf = open(out+".fasta", "w")
	for i in nm:
		if serotype in i:
			wf.write(">"+i+"\n")
			wf.write(seq.get(i)+"\n")
	wf.close()

def snp_blast(genome, snp):
	"""
	Parameters
	----------
	genome : query genome
		input query genome.
	snp : snp_sites.ffn
		snp site and snp sequence.

	Returns
	-------
	blast result
	"""
	os.system("makeblastdb -in %s -dbtype nucl -out test_db" % snp)
	os.system("blastn -query %s -db test_db -outfmt 6 -out test.txt" % genome)
	result = open("test.txt").readline()
	if len(result) == 0:
		return("bad")
	else:
		return(result)

def generate_snp(genome, snp):
	"""
	Parameters
	----------
	genome : query genome
		input query genome.
	snp : snp_sites.ffn
		snp site and snp sequence.
	Returns
	-------
	dictionary containing snp fragment information and sequences.
	"""
	dit_result = dict()
	lst = list()
	with open(snp) as f:
		for line in f:
			if line.startswith(">"):
				m = line.rstrip("\n").split(" ")[0][1:].split("_")[0]
				if m not in lst:
					lst.append(m)
	SNP = seperate_sequence(snp)
	dit_len = dict()
	dit_SNP = dict()
	for i in SNP[0]:
		m = i.split(" ")[0]
		dit_len[m] = SNP[2].get(i)
		dit_SNP[m] = i[i.find(" ")+1:]
	geno = seperate_sequence(genome)
	
	for i in lst:
		wf = open("%s.fasta" % i, "w")
		with open(snp) as f:
			for line in f:
				if line.startswith(">"):
					if line.rstrip("\n").split(" ")[0][1:].split("_")[0] == i:
						wf.write(line)
						wf.write(next(f))
		wf.close()
		result = snp_blast(genome=genome, snp=i+".fasta")
		if result != "bad":
			result_split = result.rstrip("\n").split("\t")
			coverage = (int(result_split[7])-int(result_split[6])+1)/dit_len.get(result_split[1])
			similarity = float(result_split[2])
			if coverage == 1:
				if similarity > 90:
					my_sequence = geno[1].get(result_split[0])[int(result_split[6])-1:int(result_split[7])]
					if int(result_split[8] < result_split[9]):
						aim_sequence = my_sequence
					else:
						aim_sequence = Seq(my_sequence)
						aim_sequence = aim_sequence.reverse_complement()
						aim_sequence = str(aim_sequence)
					fragment = result_split[1].split("_")[0]
					snp_site = dit_SNP.get(result_split[1]).split(" ")
					fragment_snp = ""
					for site in snp_site:
						fragment_snp += aim_sequence[int(site)]
					dit_result[fragment] = fragment_snp
		os.remove("%s.fasta" % i)
	os.remove("test.txt")
	os.remove("test_db.nhr")
	os.remove("test_db.nin")
	os.remove("test_db.nsq")
	return(dit_result)

def generate_blast(OACs, gene, genome):
	"""
	Parameters
	----------
	OACs : seperate_sequence generated data
		negerated by seperate_seqeunce function.
	gene : input gene
		the query gene.
	genome : input genome
		the input genome.
	Returns
	-------
	blast result
	"""
	wf = open(gene+".fasta", "w")
	m1 = list(OACs)[0]
	m2 = list(OACs)[1]
	for i in m1:
		if gene in i:
			wf.write(">"+i+"\n")
			wf.write(m2.get(i)+"\n")
	wf.close()
	os.system("makeblastdb -in "+gene+".fasta "+"-dbtype nucl "+"-out "+gene)
	os.system("blastn -query "+genome+" -db "+gene+" -outfmt 6 -out "+gene+".txt")
	result = open(gene+".txt").readline()
	os.remove(gene+".txt")
	os.remove(gene+".fasta")
	os.remove(gene+".nhr")
	os.remove(gene+".nin")
	os.remove(gene+".nsq")

	if len(result) == 0:
		return("bad")
	else:
		return(result)

def O_antigen_cluster(OACs, genome, outfmt = 0):

	O_AGCs = seperate_sequence(OACs)
	g_name = genome[::-1]
	g_name = g_name[g_name.find(".")+1:][::-1]
	new_genome = seperate_sequence(genome)
	galF_result = generate_blast(OACs=O_AGCs, genome=genome, gene="galF")
	gnd_result = generate_blast(OACs=O_AGCs, genome=genome, gene="gnd")

	if galF_result=="bad" or gnd_result=="bad":
		return("bad")
	else:
		galF_split = galF_result.split("\t")
		gnd_split  = gnd_result.split("\t")
		if galF_split[0] == gnd_split[0]:
			galF_identity = float(galF_split[2])
			gnd_identity = float(gnd_split[2])
			galF_coverage = float(galF_split[3])/891
			gnd_coverage = float(gnd_split[3])/1407
			if galF_coverage > 0.6 and gnd_coverage > 0.6 and galF_identity > 80 and gnd_identity > 80:
				aim_sequence = list(new_genome)[1].get(galF_split[0])
				lst = [int(galF_split[6]), int(galF_split[7]), int(gnd_split[6]), int(gnd_split[7])]
				my_sequence = aim_sequence[min(lst)-1:max(lst)]
				if float(galF_split[6]) < float(gnd_split[6]) and float(galF_split[8]) < float(galF_split[9]):
					if outfmt == 0:
						return("yes")
					elif outfmt == 1:
						return(my_sequence)
				elif float(galF_split[6]) > float(gnd_split[6]) and float(galF_split[8]) > float(galF_split[9]):
					my_sequence = Seq(my_sequence)
					my_sequence = my_sequence.reverse_complement()
					my_sequence = str(my_sequence)
					if outfmt == 0:
						return("yes")
					elif outfmt == 1:
						return(my_sequence)
				else:
					return("bad")
		else:
			return("bad")

def batch_clusters(genome_dir, OACs, prefix="O_antigen_clusters"):
	wf = open("%s.fasta" % prefix, "w")
	g_path = os.path.abspath(genome_dir)
	for i in os.listdir(g_path):
		tran_sequence(sequence=i, path1=g_path, path2=os.getcwd())
		g_name = i[::-1]
		g_name = g_name[g_name.find(".")+1:][::-1]
		cluster = O_antigen_cluster(OACs=OACs, genome="%s_re.fasta" % g_name, outfmt=1)
		wf.write(">%s\n" % g_name)
		if cluster == "bad":
			wf.write("poor quality genome\n")
		else:
			wf.write("%s\n" % cluster)
		os.remove("%s_re.fasta" % g_name)
	wf.close()

def O_serotype(OACs_sequence, genome, species):
	g_name = genome[::-1]
	g_name = g_name[g_name.find(".")+1:][::-1]

	serotype = species_Oserotype.get(species)
	OACs = list(seperate_sequence(OACs_sequence))
	contig_name = OACs[0]
	contig_sequence = OACs[1]
	wf = open("specific_gene.fasta", "w")
	for i in contig_name:
		for sero in serotype:
			if sero in i:
				if "wzx" in i or "wzm" in i:
					wf.write(">"+i+"\n")
					wf.write(contig_sequence.get(i)+"\n")
	wf.close()
	wzx_wzm = seperate_sequence("specific_gene.fasta")

	os.system("makeblastdb -in specific_gene.fasta -dbtype nucl -out wzx_or_wzm")
	os.system("blastn -query "+genome+" -db wzx_or_wzm -outfmt 6 -out wzx_or_wzm.txt")
	result = open("wzx_or_wzm.txt").readline()
	os.remove("wzx_or_wzm.txt")
	os.remove("wzx_or_wzm.nhr")
	os.remove("wzx_or_wzm.nin")
	os.remove("wzx_or_wzm.nsq")
	os.remove("specific_gene.fasta")

	if len(result) == 0:
		new_type = O_antigen_cluster(OACs = OACs_sequence, genome = genome, outfmt = 0)
		if new_type == "yes":
			return("new")
		else:
			return("bad")
	else:
		result_split = result.split("\t")
		result_identity = float(result_split[2])
		coverage = float(result_split[3])/float(list(wzx_wzm)[2].get(result_split[1]))
		if result_identity > 90:
			if coverage > 0.5:
				idetified_serotype = result_split[1].split("_")[0]
				return(idetified_serotype)
			else:
				return("bad")
		else:
			new_type = O_antigen_cluster(OACs = OACs_sequence, genome = genome, outfmt = 0)
			if new_type == "yes":
				return("new")
			else:
				return("bad")

def O_DO1(OACs_sequence, genome):
	OACs = list(seperate_sequence(OACs_sequence))
	contig_sequence = OACs[1]
	wf = open("weoB_gene.fasta", "w")
	wf.write(">DO1\n")
	wf.write("%s\n" % contig_sequence.get("DO1a_weoB"))
	wf.close()
	os.system("makeblastdb -in weoB_gene.fasta -dbtype nucl -out weoB")
	os.system("blastn -query "+genome+" -db weoB -outfmt 6 -out weoB.txt")
	result = open("weoB.txt").readline()
	os.remove("weoB.txt")
	os.remove("weoB.nhr")
	os.remove("weoB.nin")
	os.remove("weoB.nsq")
	os.remove("weoB_gene.fasta")
	if len(result) == 0:
		return("DO1b")
	else:
		result_split = result.split("\t")
		result_identity = float(result_split[2])
		result_coverage = int(abs(int(result_split[8])-int(result_split[9]))+1)/(OACs[2].get("DO1a_weoB"))
		if result_identity > 90 and result_coverage > 0.8:
			return("DO1a")
		else:
			return("DO1b")

def extract_MLST(MLST_seq, genome, STtype):
	genome_seq = seperate_sequence(genome)
	genome_contig_seq = list(genome_seq)[1]
	MLST = seperate_sequence(MLST_seq)
	contig_len = list(MLST)[2]
	st_dit = dict()
	st_lst = list()
	with open(STtype) as f:
		for line in f:
			m=line.strip("\n").split("\t")
			st_dit[m[0]] = m[1]
			st_lst.append(m[0])
	gene_type = list()
	for i in seven_genes:
		result = generate_blast(OACs = MLST, genome = genome, gene = i)
		if result == "bad":
			return("bad")
		else:
			result_split = result.strip("\n").split("\t")
			result_identity = float(result_split[2])
			result_coverage = (float(result_split[7])-float(result_split[6])+1)/float(contig_len.get(result_split[1]))
			if result_coverage == 1:
				aim_seq = genome_contig_seq.get(result_split[0])[int(result_split[6])-1:int(result_split[7])]
				aim_seq = aim_seq.upper()
				atcg = aim_seq.count("A")+aim_seq.count("T")+aim_seq.count("G")+aim_seq.count("C")
				if atcg == len(aim_seq):
					if result_identity == 100:
						gene_type.append(result_split[1])
					elif 90 < result_identity < 100:
						gene_type.append(i+"_n")
					else:
						return("bad")
				else:
					return("bad")
			else:
				return("bad")

	st_type = "-".join(gene_type)
	if st_type in st_lst:
		return(st_dit.get(st_type))
	else:
		return("new")

def phylo_tree(ref_snp, genome, snp_seq, tree_p):
	"""
	Parameters
	----------
	ref_snp : ref_snp.ffn
		snp sequence from reference strans from Cronobacter seven species.
	genome : query genome
		input query genome.
	snp_seq : snp_sites.ffn
		snp site and snp sequence.
	align_p : align.mao
		megacc alignment parameter file.
	tree_p : tree.mao
		megacc phylogeny parameter file.
	Returns
	-------
	identified species of Cronobacter
	"""
	g_name = genome[::-1]
	g_name = g_name[g_name.find(".")+1:][::-1]
	snp = generate_snp(genome=genome, snp=snp_seq)
	snp_fragment = list(snp.keys())
	if len(snp) <= 50:
		aim_species = "bad"
	else:
		wf = open("test.fasta", "w")
		wf.write(">%s\n" % g_name)
		for i in snp_fragment:
			wf.write(snp.get(i))
		wf.write("\n")
		new_species = list()
		with open(ref_snp) as f:
			for line in f:
				if line.startswith(">"):
					new_species.append(line[1:line.find("_")])
		new_species = list(set(new_species))
		for i in new_species:
			new_dit = dict()
			with open(ref_snp) as f:
				for line in f:
					if line.startswith(">%s" % i):
						new_dit[line[line.find("_")+1:-1]] = next(f).rstrip("\n")
			wf.write(">%s\n" % i)
			for ni in snp_fragment:
				wf.write(new_dit.get(ni))
			wf.write("\n")
		wf.close()
	os.system("megacc -n -a %s -d test.fasta -o test" % tree_p)

	if os.path.exists("test.nwk"):
		tree = Phylo.read("test.nwk", "newick")
		tree.root_with_outgroup("condimenti0")
		Phylo.write(tree, "test1.nwk", format = "newick")

		wlu1 = extract_species(tree="test.nwk",genome_name=g_name,species=seven_species)
		wlu2 = extract_species(tree="test1.nwk",genome_name=g_name,species=seven_species)
		if wlu1 in seven_species:
			aim_species = wlu1
		else:
			if wlu2 in seven_species:
				aim_species = wlu2
			else:
				aim_species = "bad"

	else:
		aim_species = "bad"
	if os.path.exists("test.fasta"):
		os.remove("test.fasta")
	if os.path.exists("test.nwk"):
		os.remove("test.nwk")
	if os.path.exists("test1.nwk"):
		os.remove("test1.nwk")
	if os.path.exists("test_summary.txt"):
		os.remove("test_summary.txt")
	return(aim_species)


def CroTrait(genome_dir, \
			ref_snp="ref_snp.ffn", snp_seq="snp_sites.ffn", \
			tree_p="tree.mao", \
			OACs="OAGCs.ffn", \
			MLST_seq="ST_alleles.ffn", STtype="STs.txt", \
			prefix="Cronobacter_MLST_Oserotype",
			sp = "unknown"):
	wf = open("%s.txt" % prefix, "w")
	if sp == "unknown":
		wf.write("%s\t%s\t%s\t%s\n" % ("id","species","O_type","ST"))
	else:
		wf.write("%s\t%s\t%s\n" % ("id","O_type","ST"))
	g_path = os.path.abspath(genome_dir)
	for i in os.listdir(g_path):
		tran_sequence(sequence=i, path1=g_path, path2=os.getcwd())
		g_name = i[::-1]
		g_name = g_name[g_name.find(".")+1:][::-1]
		ST = extract_MLST(MLST_seq=MLST_seq, genome="%s_re.fasta" % g_name, STtype=STtype)
		if sp == "unknown":
			aim_species = phylo_tree(genome="%s_re.fasta" % g_name,
									ref_snp=ref_snp, snp_seq=snp_seq,
									tree_p=tree_p)
			if aim_species == "bad":
				O_type = "bad"
			else:
				O_type = O_serotype(genome="%s_re.fasta" % g_name,
									OACs_sequence=OACs, species=aim_species)
				if "DO1" in O_type:
					O_type = O_DO1(OACs_sequence=OACs, genome="%s_re.fasta" % g_name)
			wf.write("%s\t%s\t%s\t%s\n" % (g_name,aim_species,O_type,ST))
		else:
			aim_species = sp
			O_type = O_serotype(genome="%s_re.fasta" % g_name,
								OACs_sequence=OACs, species=aim_species)
			if "DO1" in O_type:
				O_type = O_DO1(OACs_sequence=OACs, genome="%s_re.fasta" % g_name)
			wf.write("%s\t%s\t%s\n" % (g_name,O_type,ST))
		os.remove("%s_re.fasta" % g_name)
	wf.close()


def stat_cat(df, cat):
	dit = {cat:[], "amount":[], "percent":[]}
	sp = df[cat].value_counts()
	for i in list(sp.index):
		if i not in ["bad", "new"]:
			dit.get(cat).append(i)
			dit.get("amount").append(sp[i])
			dit.get("percent").append(sp[i]/df.shape[0])
	if "new" in sp.index:
		dit.get(cat).append("new")
		dit.get("amount").append(sp["new"])
		dit.get("percent").append(sp["new"]/df.shape[0])
	if "bad" in sp.index:
		dit.get(cat).append("bad")
		dit.get("amount").append(sp["bad"])
		dit.get("percent").append(sp["bad"]/df.shape[0])
	return(dit)

def stat_2cat(df, cat1, cat2):
	dit = {cat1:[], cat2:[], "amount":[], "percent":[]}
	sp = df[cat1].value_counts()
	for i in list(sp.index):
		data = df[df.species == i]
		ot = data[cat2].value_counts()
		if i != "bad":
			for i1 in list(ot.index):
				if i1 not in ["bad", "new"]:
					dit.get(cat1).append(i)
					dit.get(cat2).append(i1)
					dit.get("amount").append(ot[i1])
					dit.get("percent").append(ot[i1]/df.shape[0])
			if "new" in list(ot.index):
				dit.get(cat1).append(i)
				dit.get(cat2).append("new")
				dit.get("amount").append(ot["new"])
				dit.get("percent").append(ot["new"]/df.shape[0])
			if "bad" in list(ot.index):
				dit.get(cat1).append(i)
				dit.get(cat2).append("bad")
				dit.get("amount").append(ot["bad"])
				dit.get("percent").append(ot["bad"]/df.shape[0])

	for i in list(sp.index):
		data = df[df.species == i]
		ot = data[cat2].value_counts()
		if i == "bad":
			for i1 in list(ot.index):
				if i1 not in ["bad", "new"]:
					dit.get(cat1).append(i)
					dit.get(cat2).append(i1)
					dit.get("amount").append(ot[i1])
					dit.get("percent").append(ot[i1]/df.shape[0])
			if "new" in list(ot.index):
				dit.get(cat1).append(i)
				dit.get(cat2).append("new")
				dit.get("amount").append(ot["new"])
				dit.get("percent").append(ot["new"]/df.shape[0])
			if "bad" in list(ot.index):
				dit.get(cat1).append(i)
				dit.get(cat2).append("bad")
				dit.get("amount").append(ot["bad"])
				dit.get("percent").append(ot["bad"]/df.shape[0])
	return(dit)

def stat_3cat(df, cat1, cat2, cat3):
	dit = {cat1:[], cat2:[], cat3:[], "amount":[], "percent":[]}
	sp = df[cat1].value_counts()
	for i in list(sp.index):
		data = df[df.species == i]
		ot = data[cat2].value_counts()
		if i != "bad":
			for i1 in list(ot.index):
				data1 = data[data.O_type==i1]
				st = data1[cat3].value_counts()
				if i1 not in ["bad", "new"]:
				# MLST types
					for i2 in list(st.index):
						if i2 not in ["bad", "new"]:
							dit.get(cat1).append(i)
							dit.get(cat2).append(i1)
							dit.get(cat3).append(i2)
							dit.get("amount").append(st[i2])
							dit.get("percent").append(st[i2]/df.shape[0])
					if "new" in list(st.index):
						dit.get(cat1).append(i)
						dit.get(cat2).append(i1)
						dit.get(cat3).append("new")
						dit.get("amount").append(st["new"])
						dit.get("percent").append(st["new"]/df.shape[0])
					if "bad" in list(st.index):
						dit.get(cat1).append(i)
						dit.get(cat2).append(i1)
						dit.get(cat3).append("bad")
						dit.get("amount").append(st["bad"])
						dit.get("percent").append(st["bad"]/df.shape[0])
			for i1 in list(ot.index):
				data1 = data[data.O_type==i1]
				st = data1[cat3].value_counts()
				if i1 == "new":
				# MLST types
					for i2 in list(st.index):
						if i2 not in ["bad", "new"]:
							dit.get(cat1).append(i)
							dit.get(cat2).append(i1)
							dit.get(cat3).append(i2)
							dit.get("amount").append(st[i2])
							dit.get("percent").append(st[i2]/df.shape[0])
					if "new" in list(st.index):
						dit.get(cat1).append(i)
						dit.get(cat2).append(i1)
						dit.get(cat3).append("new")
						dit.get("amount").append(st["new"])
						dit.get("percent").append(st["new"]/df.shape[0])
					if "bad" in list(st.index):
						dit.get(cat1).append(i)
						dit.get(cat2).append(i1)
						dit.get(cat3).append("bad")
						dit.get("amount").append(st["bad"])
						dit.get("percent").append(st["bad"]/df.shape[0])
			for i1 in list(ot.index):
				data1 = data[data.O_type==i1]
				st = data1[cat3].value_counts()
				if i1 == "bad":
				# MLST types
					for i2 in list(st.index):
						if i2 not in ["bad", "new"]:
							dit.get(cat1).append(i)
							dit.get(cat2).append(i1)
							dit.get(cat3).append(i2)
							dit.get("amount").append(st[i2])
							dit.get("percent").append(st[i2]/df.shape[0])
					if "new" in list(st.index):
						dit.get(cat1).append(i)
						dit.get(cat2).append(i1)
						dit.get(cat3).append("new")
						dit.get("amount").append(st["new"])
						dit.get("percent").append(st["new"]/df.shape[0])
					if "bad" in list(st.index):
							dit.get(cat1).append(i)
							dit.get(cat2).append(i1)
							dit.get(cat3).append("bad")
							dit.get("amount").append(st["bad"])
							dit.get("percent").append(st["bad"]/df.shape[0])

	for i in list(sp.index):
		data = df[df.species==i]
		ot = data[cat2].value_counts()
		# O serotype
		if i == "bad":
			for i1 in list(ot.index):
				data1 = data[data.O_type==i1]
				st = data1[cat3].value_counts()
				if i1 == "bad":
					for i2 in list(st.index):
						if i2 not in ["bad", "new"]:
							dit.get(cat1).append(i)
							dit.get(cat2).append(i1)
							dit.get(cat3).append(i2)
							dit.get("amount").append(st[i2])
							dit.get("percent").append(st[i2]/df.shape[0])
					if "new" in list(st.index):
						dit.get(cat1).append(i)
						dit.get(cat2).append(i1)
						dit.get(cat3).append("new")
						dit.get("amount").append(st["new"])
						dit.get("percent").append(st["new"]/df.shape[0])
					if "bad" in list(st.index):
						dit.get(cat1).append(i)
						dit.get(cat2).append(i1)
						dit.get(cat3).append("bad")
						dit.get("amount").append(st["bad"])
						dit.get("percent").append(st["bad"]/df.shape[0])
	return(dit)

def stat_summary(df):
	df = pd.read_table(df)
	category = list(df.columns[1:])
	for i in category:
		m = stat_cat(df, i)
		m = pd.DataFrame(data=m)
		m.to_csv("statisticed_by_%s.txt" % i, index=False, sep="\t")
	#
	m = stat_2cat(df=df, cat1="species", cat2="O_type")
	m = pd.DataFrame(data=m)
	m.to_csv("statisticed_by_speciesAndO_type.txt", index=False, sep="\t")
	#
	m = stat_2cat(df=df, cat1="species", cat2="ST")
	m = pd.DataFrame(data=m)
	m.to_csv("statisticed_by_speciesAndST.txt", index=False, sep="\t")
	#
	m = stat_3cat(df=df, cat1="species", cat2="O_type",cat3="ST")
	m = pd.DataFrame(data=m)
	m.to_csv("statisticed_by_speciesAndO_typeAndST.txt", index=False, sep="\t")

def visualization(Cro_result, prefix="stat_visual"):

	df = pd.read_table(Cro_result)
	m = stat_cat(df, cat="species")
	df1 = pd.DataFrame(data=m)
	m = stat_2cat(df,cat1="species", cat2="O_type")
	df2 = pd.DataFrame(data=m)
	m = stat_3cat(df, cat1="species", cat2="O_type", cat3="ST")
	df3 = pd.DataFrame(data=m)

	fig = plt.figure(figsize=(6,6), dpi=100)
	ax = fig.add_subplot(1,1,1, projection="polar")
	ax.set_axis_off()
	ax.set_theta_direction(-1)
	ax.set_theta_zero_location("N")

	# the inner circle for species
	unit = np.pi*2*7/8/df1["amount"].sum()
	df1["width"] = df1["amount"]*unit
	df1["theta"] = df1["width"].cumsum()
	s_color = ["#00aeff","#3369e7","#8e43e7","#b84592","#ff6c5f","#ffc168","#2dde98"]
	for i in range(df1.shape[0]):
		if df1["species"][i] == "bad":
			color = "red"
		else:
			color = random.choice(s_color)
			s_color.remove(color)
		ax.bar(df1["theta"][i]-df1["width"][i]/2, 15,
			width=df1["width"][i]-np.pi/180,
			bottom= 15, align="center", color=color)
		ax.text(df1["theta"][i]-df1["width"][i]/2, 22.5,
				"%s  %.2f" % (df1["species"][i], df1["percent"][i]*100)+"%",
				ha="center", va="center", size=3,
				rotation=(90+(360-np.degrees(df1["theta"][i]-df1["width"][i]/2)%180))%360,
				name="Times New Roman")

	# the medium circle for O serotype
	df2["width"] = df2["amount"]*unit
	df2["theta"] = df2["width"].cumsum()
	o_num = list(df2["O_type"].unique())
	o_color = dict()
	for i in o_num:
		o_color[i] = randomcolor()
	for i in range(df2.shape[0]):
		if df2["O_type"][i] == "bad":
			color = "red"
			ax.bar(df2["theta"][i]-df2["width"][i]/2, 10, width=df2["width"][i]-np.pi/480,
					bottom= 32, align="center", color=color)
			if df2["percent"][i]*100 > 0.5:
				ax.text(df2["theta"][i]-df2["width"][i]/2, 37,
						"%s  %.2f" % (df2["O_type"][i], df2["percent"][i]*100)+"%",
						ha="center", va="center",size=3,
						rotation=(90+(360-np.degrees(df2["theta"][i]-df2["width"][i]/2)%180))%360,
						name="Times New Roman")
		elif df2["O_type"][i] == "new":
			color = "blue"
			ax.bar(df2["theta"][i]-df2["width"][i]/2, 5, width=df2["width"][i]-np.pi/480,
					bottom= 43, align="center", color=color)
		else:
			color = o_color.get(df2["O_type"][i])
			ax.bar(df2["theta"][i]-df2["width"][i]/2, 10, width=df2["width"][i]-np.pi/480,
					bottom= 32, align="center", color=color)
			if df2["percent"][i]*100 > 0.5:
				ax.text(df2["theta"][i]-df2["width"][i]/2, 37,
						"%s  %.2f" % (df2["O_type"][i], df2["percent"][i]*100)+"%",
						ha="center", va="center",size=3,
						rotation=(90+(360-np.degrees(df2["theta"][i]-df2["width"][i]/2)%180))%360,
						name="Times New Roman")

	# the outer circle for MLST type
	df3["width"] = df3["amount"]*unit
	df3["theta"] = df3["width"].cumsum()
	t_num = list(df3["ST"].unique())
	t_color = dict()
	for i in t_num:
		t_color[i] = randomcolor()
	for i in range(df3.shape[0]):
		if df3["ST"][i] == "bad":
			color = "red"
			ax.bar(df3["theta"][i]-df3["width"][i]/2, 10, width=df3["width"][i]-np.pi/1800,
					bottom= 50, align="center", color=color)
			if df3["percent"][i]*100 > 0.5:
				ax.text(df3["theta"][i]-df3["width"][i]/2, 55,
						"%s  %.2f" % (df3["ST"][i], df3["percent"][i]*100)+"%",
						ha="center", va="center",size=3,
						rotation=(90+(360-np.degrees(df3["theta"][i]-df3["width"][i]/2)%180))%360,
						name="Times New Roman")
		elif df3["ST"][i] == "new":
			color = "blue"
			ax.bar(df3["theta"][i]-df3["width"][i]/2, 5, width=df3["width"][i]-np.pi/1800,
					bottom= 61, align="center", color=color)
			if df3["percent"][i]*100 > 0.5:
				ax.text(df3["theta"][i]-df3["width"][i]/2, 55,
						"%s  %.2f" % (df3["ST"][i], df3["percent"][i]*100)+"%",
						ha="center", va="center",size=3,
						rotation=(90+(360-np.degrees(df3["theta"][i]-df3["width"][i]/2)%180))%360,
						name="Times New Roman")
		else:
			color = t_color.get(df3["ST"][i])
			if list(df3["ST"]).count(df3["ST"][i]) > 1:
				ax.bar(df3["theta"][i]-df3["width"][i]/2, 5, width=df3["width"][i]-np.pi/1800,
						bottom= 67, align="center", color=color)
				if df3["percent"][i]*100 > 0.5:
					ax.text(df3["theta"][i]-df3["width"][i]/2, 55,
							"%s  %.2f" % (df3["ST"][i], df3["percent"][i]*100)+"%",
							ha="center", va="center",size=3,
							rotation=(90+(360-np.degrees(df3["theta"][i]-df3["width"][i]/2)%180))%360,
							name="Times New Roman")
			else:
				ax.bar(df3["theta"][i]-df3["width"][i]/2, 10, width=df3["width"][i]-np.pi/1800,
						bottom= 50, align="center", color=color)
				if df3["percent"][i]*100 > 0.5:
					ax.text(df3["theta"][i]-df3["width"][i]/2, 55,
							"%s  %.2f" % (df3["ST"][i], df3["percent"][i]*100)+"%",
							ha="center", va="center",size=3,
							rotation=(90+(360-np.degrees(df3["theta"][i]-df3["width"][i]/2)%180))%360,
							name="Times New Roman")
	# text Cronobacter in the center
	ax.text(0,0,"Cronobacter",
		ha="center", va="center", weight="bold",fontstyle="italic",
		color="k", size=6, name="Times New Roman")
	# draw the solid line
	r = [14,31,49,73]
	theta = np.linspace(0, np.pi*14/8, 1000)
	for i in r:
		ax.plot(theta, [i]*1000, ls="-", linewidth=1, color="k")
	# draw the dash line
	r = [42.5, 60.5, 66.5]
	for i in r:
		ax.plot(theta, [i]*1000, ls="--", linewidth=0.5, color="k")

	plt.savefig("%s.pdf" % prefix)

def arrow_table(OACs_sequence, serotype, ref_fna, aim_fna):
	extract_type(sequence=OACs_sequence, serotype=serotype, out=serotype)
	extract_type(sequence=ref_fna, serotype=serotype, out=serotype+"_ref")
	os.system("makeblastdb -in %s.fasta -dbtype nucl -out %s_db" % (serotype, serotype))
	os.system("blastn -query %s_ref.fasta -db %s_db -outfmt 6 -out %s.txt" % (serotype, serotype, serotype))
	os.system("blastn -query %s -db %s_db -outfmt 6 -out %s.txt" % (aim_fna, serotype, serotype+"_aim"))

	def handle_data(data):
		data = data.sort_values(by=[6])
		orit = []
		for i in range(data.shape[0]):
			if data.iloc[i,8] < data.iloc[i,9]:
				orit.append("+")
			else:
				orit.append("-")
		data["ori"] = orit
		data = data.iloc[:, [0,1,2,6,7,12]]
		return(data)
	data1 = pd.read_table("%s.txt" % (serotype), sep="\t", header=None)
	data1 = handle_data(data1).reset_index(drop=True)
	data2 = pd.read_table("%s_aim.txt" % (serotype), sep="\t", header=None)
	data2 = handle_data(data2).reset_index(drop=True)

	os.remove("%s.fasta" % (serotype))
	os.remove("%s_ref.fasta" % (serotype))
	os.remove("%s.txt" % (serotype))
	os.remove("%s_aim.txt" % (serotype))
	os.remove("%s_db.nhr" % (serotype))
	os.remove("%s_db.nin" % (serotype))
	os.remove("%s_db.nsq" % (serotype))

	if list(data1[1]) == list(data2[1]):
		data3 = pd.merge(data1, data2, on=1)
		return(data3)
	else:
		return("bad")

def arrow_origin(data, out):
	fig = plt.figure(figsize=(6,2), dpi=100)
	ax = fig.add_subplot(1,1,1)
	ax.set_axis_off()

	nm = data[1][0]
	serotype = nm.split("_")[0]
	xlim = [1-1500, data["7_x"][data.shape[0]-1]+500]
	ylim = [0, 1]
	ax.set_xlim(xlim)
	ax.set_ylim(ylim)
	ax.text(-750,0.7,serotype,
			ha="center", va="center",size=10,
			name="Times New Roman",weight="bold",
			fontstyle="normal")
	ax.text(-750,0.45,"similarity",
			ha="center", va="center",size=8,
			name="Times New Roman",weight="bold",
			rotation=0,
			fontstyle="normal")
	ax.text(-750,0.2,data["0_y"][0],
			ha="center", va="center",size=10,
			name="Times New Roman",weight="bold",
			rotation=0,
			fontstyle="normal")

	for i in range(data.shape[0]):
		gene_name = data[1][i].split("_")[1]
		wzx = ["wzx","wzy","wzm","wzt"]
		galF = ["galF", "gnd"]
		if gene_name in wzx:
			color="#da1884"
		elif gene_name in galF:
			color="k"
		else:
			color="#8e43e7"
		if data["ori_x"][i] == "+":
			x1 = data["6_x"][i]
			x2 = data["6_y"][i]
			dx1 = data["7_x"][i] - x1 + 1
			dx2 = data["7_y"][i] - x1 + 1
		else:
			x1 = data["7_x"][i]
			x2 = data["7_y"][i]
			dx1 = (data["7_x"][i] - x1 + 1)*(-1)
			dx2 = (data["7_y"][i] - x2 + 1)*(-1)
		y1 = 0.7
		y2 = 0.2
		dy1 = dy2 = 0
		width = 0.2
		head_width =2 * width
		ax.arrow(x1, y1, dx1, dy1,
				width=width,
				head_width=head_width,
				length_includes_head=True, head_length=350,
				ec="white", color=color)
		ax.arrow(x2, y2, dx2, dy2,
				width=width,
				head_width=head_width,
				length_includes_head=True, head_length=350,
				ec="white", color=color)
		ax.text(x1+dx1/2, 0.95, gene_name,
		     ha="center", va="center",size=8,
			 name="Times New Roman",weight="bold",
			 rotation=45, fontstyle="italic")
		ax.text(x1+dx1/2, 0.45, str(round(data["2_y"][i],2)),
		     ha="center", va="center",size=8,
			 name="Times New Roman", weight="bold",
			 rotation=45, fontstyle="italic")
	plt.savefig("%s.pdf" % out)

def arrow_draw(OACs_sequence, genome, species, ref_fna):
	abs_path = os.path.abspath(genome)
	base_name = os.path.basename(abs_path)
	tran_sequence(sequence=base_name)
	g_name = base_name[::-1]
	g_name = g_name[g_name.find(".")+1:][::-1]
	print(g_name)
	if species == "bad":
		O_result = "species unidentified"
	else:
		O_type = O_serotype(OACs_sequence=OACs_sequence, genome="%s_re.fasta" % g_name, species=species)
		if "DO1" in O_type:
			O_type = O_DO1(OACs_sequence=OACs_sequence, genome="%s_re.fasta" % g_name)
		if O_type == "bad":
			O_result = "genome quality of %s is poor and O serotype cannot be identified."
		elif O_type == "new":
			O_result = "%s is a potential new O serotype of %s." % (g_name, species)
		else:
			O_sequence = O_antigen_cluster(OACs=OACs_sequence, genome="%s_re.fasta" % g_name, outfmt=1)
			if O_sequence == "bad":
				O_result = "%s belongs to %s but no complete O-antigen gene cluster sequence" % (g_name, O_type)
			else:
				wf = open("%s_Ocluster.fna" % g_name, "w")
				wf.write(">%s\n" % g_name)
				wf.write("%s\n" % O_sequence)
				wf.close()
				O_result = "%s" % O_type

				at = arrow_table(OACs_sequence=OACs_sequence, serotype=O_result,
					  				ref_fna=ref_fna, aim_fna="%s_Ocluster.fna" % g_name)
				if type(at) == str:
					O_result = "%s but maybe there is new sub O serotypes" % O_type
				else:
					arrow_origin(data=at, out="%s_Ocluster" % g_name)
					O_result = O_type
	os.remove("%s_re.fasta" % g_name)
	return(O_result)

def res_path(path):
    if getattr(sys, 'frozen', False): #是否Bundle Resource
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, path)

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description="useage: CroTrait [options]")
	parser.add_argument("-d", "--directory",
						help="the directory contaning the genome sequences")
	parser.add_argument("-t", "--functiontype", choices=[1,2,3,4,5], type=int, default=1,
						help="choice the needed function")
	parser.add_argument("-s", "--species", \
						choices=["condimenti","dublinensis","malonaticus","muytjensii","sakazakii","turicensis","universalis", "unknown"],\
						type=str, default="unknown",\
						help="choice the species of Cronobacter")
	parser.add_argument("-e", "--tree", default="tree.mao",
						help = "build tree paramter file")
	parser.add_argument("-p", "--prefix", default="result",
						help="prefix of result")
	parser.add_argument("-r", "--result_table", \
						help="the result table generated by CroTrait")
	args = parser.parse_args()

	MLST_seq = res_path(os.path.join("template","ST_alleles.ffn"))
	ST_type = res_path(os.path.join("template","STs.txt"))
	OAGCs_ffn = res_path(os.path.join("template","OAGCs.ffn"))
	OAGCs_fna = res_path(os.path.join("template","OAGCs.fna"))
	ref_snp = res_path(os.path.join("template","ref_snp.ffn"))
	snp_site = res_path(os.path.join("template","snp_sites.ffn"))
	tree_p = res_path(os.path.join("template","tree.mao"))


	if args.functiontype == 1:
		sy = platform.system()
		if sy == "Windows":
			ab1 = subprocess.call("where blastn")
			ab2 = subprocess.call("where megacc")
			if ab1 == 0 and ab2 == 0:
				print("Please cite: Wang Lu, Zhu Wenxuan, Lu Gege et al. CroTrait: in silico identifier of species, O serotypes and sequence types of Cronoabcter genus.")
			else:
				print("blastn or/and megacc are not in your path, please install or add them here!")
		elif sy == "Linux":
			ab1 = subprocess.call("where blastn")
			ab2 = subprocess.call("where megacc")
			if ab1 == 0 and ab2 == 0:
				print("Please cite: Wang Lu, et al. CroTrait: in silico identifier of species, O serotypes and sequence types of Cronoabcter genus.")
			else:
				print("blastn or/and megacc are not in your path, please install or add them here!")
		CroTrait(genome_dir = args.directory, \
				ref_snp = ref_snp, snp_seq = snp_site, \
				tree_p = tree_p, OACs = OAGCs_ffn, \
				MLST_seq=MLST_seq, STtype=ST_type, \
				prefix=args.prefix, sp = args.species)
	elif args.functiontype == 2:
		O_type = arrow_draw(genome=args.directory, \
							OACs_sequence=OAGCs_ffn, ref_fna=OAGCs_fna,\
							species = args.species)
		print(O_type)

	elif args.functiontype == 3:
		batch_clusters(genome_dir = args.directory, \
					OACs = OAGCs_ffn, prefix = args.prefix)

	elif args.functiontype == 4:
		stat_summary(df = args.result_table)

	elif args.functiontype == 5:
		visualization(Cro_result = args.result_table, prefix= args.prefix)


